// Copyright (c) 2013-2018 Ming Chen
// Copyright (c) 2016-2016 Praveen Kumar Morampudi
// Copyright (c) 2016-2016 Harshkumar Patel
// Copyright (c) 2017-2017 Rushabh Shah
// Copyright (c) 2013-2014 Arun Olappamanna Vasudevan
// Copyright (c) 2013-2014 Kelong Wang
// Copyright (c) 2013-2018 Erez Zadok
// Copyright (c) 2013-2018 Stony Brook University
// Copyright (c) 2013-2018 The Research Foundation for SUNY
// This file is released under the GPL.
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: secnfs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "secnfs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace secnfs {

namespace {

const ::google::protobuf::Descriptor* TimeSpec_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimeSpec_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileMeta_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileMeta_reflection_ = NULL;
const ::google::protobuf::Descriptor* Range_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Range_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyBlock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyBlock_reflection_ = NULL;
const ::google::protobuf::Descriptor* SecureContextConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SecureContextConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProxyList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProxyList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProxyEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProxyEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* FilenameEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilenameEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* DirMapFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DirMapFile_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_secnfs_2eproto() {
  protobuf_AddDesc_secnfs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "secnfs.proto");
  GOOGLE_CHECK(file != NULL);
  TimeSpec_descriptor_ = file->message_type(0);
  static const int TimeSpec_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeSpec, seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeSpec, nano_seconds_),
  };
  TimeSpec_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TimeSpec_descriptor_,
      TimeSpec::default_instance_,
      TimeSpec_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeSpec, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeSpec, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TimeSpec));
  FileHeader_descriptor_ = file->message_type(1);
  static const int FileHeader_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, keyfile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, meta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, modify_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, change_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, change_),
  };
  FileHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileHeader_descriptor_,
      FileHeader::default_instance_,
      FileHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileHeader));
  FileMeta_descriptor_ = file->message_type(2);
  static const int FileMeta_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, filesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, encrypted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, holes_),
  };
  FileMeta_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileMeta_descriptor_,
      FileMeta::default_instance_,
      FileMeta_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileMeta, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileMeta));
  Range_descriptor_ = file->message_type(3);
  static const int Range_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, length_),
  };
  Range_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Range_descriptor_,
      Range::default_instance_,
      Range_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Range));
  KeyFile_descriptor_ = file->message_type(4);
  static const int KeyFile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, creator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, key_blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, signature_),
  };
  KeyFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyFile_descriptor_,
      KeyFile::default_instance_,
      KeyFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyFile));
  KeyBlock_descriptor_ = file->message_type(5);
  static const int KeyBlock_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, proxy_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, encrypted_key_),
  };
  KeyBlock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyBlock_descriptor_,
      KeyBlock::default_instance_,
      KeyBlock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyBlock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyBlock));
  SecureContextConfig_descriptor_ = file->message_type(6);
  static const int SecureContextConfig_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, pub_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, pri_key_),
  };
  SecureContextConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SecureContextConfig_descriptor_,
      SecureContextConfig::default_instance_,
      SecureContextConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SecureContextConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SecureContextConfig));
  ProxyList_descriptor_ = file->message_type(7);
  static const int ProxyList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, proxies_),
  };
  ProxyList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProxyList_descriptor_,
      ProxyList::default_instance_,
      ProxyList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProxyList));
  ProxyEntry_descriptor_ = file->message_type(8);
  static const int ProxyEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, key_),
  };
  ProxyEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProxyEntry_descriptor_,
      ProxyEntry::default_instance_,
      ProxyEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProxyEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProxyEntry));
  FilenameEntry_descriptor_ = file->message_type(9);
  static const int FilenameEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilenameEntry, entry_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilenameEntry, encrypted_name_),
  };
  FilenameEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilenameEntry_descriptor_,
      FilenameEntry::default_instance_,
      FilenameEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilenameEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilenameEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilenameEntry));
  DirMapFile_descriptor_ = file->message_type(10);
  static const int DirMapFile_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, creator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, key_blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, filenames_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, signature_),
  };
  DirMapFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DirMapFile_descriptor_,
      DirMapFile::default_instance_,
      DirMapFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirMapFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DirMapFile));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_secnfs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimeSpec_descriptor_, &TimeSpec::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileHeader_descriptor_, &FileHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileMeta_descriptor_, &FileMeta::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Range_descriptor_, &Range::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyFile_descriptor_, &KeyFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyBlock_descriptor_, &KeyBlock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SecureContextConfig_descriptor_, &SecureContextConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProxyList_descriptor_, &ProxyList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProxyEntry_descriptor_, &ProxyEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilenameEntry_descriptor_, &FilenameEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DirMapFile_descriptor_, &DirMapFile::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_secnfs_2eproto() {
  delete TimeSpec::default_instance_;
  delete TimeSpec_reflection_;
  delete FileHeader::default_instance_;
  delete FileHeader_reflection_;
  delete FileMeta::default_instance_;
  delete FileMeta_reflection_;
  delete Range::default_instance_;
  delete Range_reflection_;
  delete KeyFile::default_instance_;
  delete KeyFile_reflection_;
  delete KeyBlock::default_instance_;
  delete KeyBlock_reflection_;
  delete SecureContextConfig::default_instance_;
  delete SecureContextConfig_reflection_;
  delete ProxyList::default_instance_;
  delete ProxyList_reflection_;
  delete ProxyEntry::default_instance_;
  delete ProxyEntry_reflection_;
  delete FilenameEntry::default_instance_;
  delete FilenameEntry_reflection_;
  delete DirMapFile::default_instance_;
  delete DirMapFile_reflection_;
}

void protobuf_AddDesc_secnfs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014secnfs.proto\022\006secnfs\"1\n\010TimeSpec\022\017\n\007se"
    "conds\030\001 \002(\004\022\024\n\014nano_seconds\030\002 \002(\004\"\253\001\n\nFi"
    "leHeader\022 \n\007keyfile\030\001 \002(\0132\017.secnfs.KeyFi"
    "le\022\014\n\004meta\030\002 \001(\014\022\017\n\007version\030\003 \001(\014\022%\n\013mod"
    "ify_time\030\004 \001(\0132\020.secnfs.TimeSpec\022%\n\013chan"
    "ge_time\030\005 \001(\0132\020.secnfs.TimeSpec\022\016\n\006chang"
    "e\030\006 \001(\004\"M\n\010FileMeta\022\020\n\010filesize\030\001 \001(\004\022\021\n"
    "\tencrypted\030\002 \001(\010\022\034\n\005holes\030\003 \003(\0132\r.secnfs"
    ".Range\"\'\n\005Range\022\016\n\006offset\030\001 \002(\004\022\016\n\006lengt"
    "h\030\002 \002(\004\"_\n\007KeyFile\022\017\n\007creator\030\001 \002(\t\022\n\n\002i"
    "v\030\002 \002(\014\022$\n\nkey_blocks\030\003 \003(\0132\020.secnfs.Key"
    "Block\022\021\n\tsignature\030\004 \001(\014\"5\n\010KeyBlock\022\022\n\n"
    "proxy_name\030\001 \002(\t\022\025\n\rencrypted_key\030\002 \002(\014\""
    "E\n\023SecureContextConfig\022\014\n\004name\030\001 \002(\t\022\017\n\007"
    "pub_key\030\002 \002(\014\022\017\n\007pri_key\030\003 \002(\014\"0\n\tProxyL"
    "ist\022#\n\007proxies\030\001 \003(\0132\022.secnfs.ProxyEntry"
    "\"\'\n\nProxyEntry\022\014\n\004name\030\001 \002(\t\022\013\n\003key\030\002 \002("
    "\014\"9\n\rFilenameEntry\022\020\n\010entry_id\030\001 \002(\r\022\026\n\016"
    "encrypted_name\030\002 \002(\014\"\214\001\n\nDirMapFile\022\017\n\007c"
    "reator\030\001 \002(\t\022\n\n\002iv\030\002 \002(\014\022$\n\nkey_blocks\030\003"
    " \003(\0132\020.secnfs.KeyBlock\022(\n\tfilenames\030\004 \002("
    "\0132\025.secnfs.FilenameEntry\022\021\n\tsignature\030\006 "
    "\001(\014", 883);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "secnfs.proto", &protobuf_RegisterTypes);
  TimeSpec::default_instance_ = new TimeSpec();
  FileHeader::default_instance_ = new FileHeader();
  FileMeta::default_instance_ = new FileMeta();
  Range::default_instance_ = new Range();
  KeyFile::default_instance_ = new KeyFile();
  KeyBlock::default_instance_ = new KeyBlock();
  SecureContextConfig::default_instance_ = new SecureContextConfig();
  ProxyList::default_instance_ = new ProxyList();
  ProxyEntry::default_instance_ = new ProxyEntry();
  FilenameEntry::default_instance_ = new FilenameEntry();
  DirMapFile::default_instance_ = new DirMapFile();
  TimeSpec::default_instance_->InitAsDefaultInstance();
  FileHeader::default_instance_->InitAsDefaultInstance();
  FileMeta::default_instance_->InitAsDefaultInstance();
  Range::default_instance_->InitAsDefaultInstance();
  KeyFile::default_instance_->InitAsDefaultInstance();
  KeyBlock::default_instance_->InitAsDefaultInstance();
  SecureContextConfig::default_instance_->InitAsDefaultInstance();
  ProxyList::default_instance_->InitAsDefaultInstance();
  ProxyEntry::default_instance_->InitAsDefaultInstance();
  FilenameEntry::default_instance_->InitAsDefaultInstance();
  DirMapFile::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_secnfs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_secnfs_2eproto {
  StaticDescriptorInitializer_secnfs_2eproto() {
    protobuf_AddDesc_secnfs_2eproto();
  }
} static_descriptor_initializer_secnfs_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int TimeSpec::kSecondsFieldNumber;
const int TimeSpec::kNanoSecondsFieldNumber;
#endif  // !_MSC_VER

TimeSpec::TimeSpec()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TimeSpec::InitAsDefaultInstance() {
}

TimeSpec::TimeSpec(const TimeSpec& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TimeSpec::SharedCtor() {
  _cached_size_ = 0;
  seconds_ = GOOGLE_ULONGLONG(0);
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimeSpec::~TimeSpec() {
  SharedDtor();
}

void TimeSpec::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimeSpec::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimeSpec::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimeSpec_descriptor_;
}

const TimeSpec& TimeSpec::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

TimeSpec* TimeSpec::default_instance_ = NULL;

TimeSpec* TimeSpec::New() const {
  return new TimeSpec;
}

void TimeSpec::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seconds_ = GOOGLE_ULONGLONG(0);
    nano_seconds_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimeSpec::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 seconds = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nano_seconds;
        break;
      }

      // required uint64 nano_seconds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nano_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nano_seconds_)));
          set_has_nano_seconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TimeSpec::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 seconds = 1;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->seconds(), output);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->nano_seconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TimeSpec::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 seconds = 1;
  if (has_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->seconds(), target);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->nano_seconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TimeSpec::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 seconds = 1;
    if (has_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->seconds());
    }

    // required uint64 nano_seconds = 2;
    if (has_nano_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nano_seconds());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimeSpec::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimeSpec* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TimeSpec*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimeSpec::MergeFrom(const TimeSpec& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
    if (from.has_nano_seconds()) {
      set_nano_seconds(from.nano_seconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimeSpec::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimeSpec::CopyFrom(const TimeSpec& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeSpec::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TimeSpec::Swap(TimeSpec* other) {
  if (other != this) {
    std::swap(seconds_, other->seconds_);
    std::swap(nano_seconds_, other->nano_seconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TimeSpec::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimeSpec_descriptor_;
  metadata.reflection = TimeSpec_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileHeader::kKeyfileFieldNumber;
const int FileHeader::kMetaFieldNumber;
const int FileHeader::kVersionFieldNumber;
const int FileHeader::kModifyTimeFieldNumber;
const int FileHeader::kChangeTimeFieldNumber;
const int FileHeader::kChangeFieldNumber;
#endif  // !_MSC_VER

FileHeader::FileHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileHeader::InitAsDefaultInstance() {
  keyfile_ = const_cast< ::secnfs::KeyFile*>(&::secnfs::KeyFile::default_instance());
  modify_time_ = const_cast< ::secnfs::TimeSpec*>(&::secnfs::TimeSpec::default_instance());
  change_time_ = const_cast< ::secnfs::TimeSpec*>(&::secnfs::TimeSpec::default_instance());
}

FileHeader::FileHeader(const FileHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileHeader::SharedCtor() {
  _cached_size_ = 0;
  keyfile_ = NULL;
  meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  modify_time_ = NULL;
  change_time_ = NULL;
  change_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileHeader::~FileHeader() {
  SharedDtor();
}

void FileHeader::SharedDtor() {
  if (meta_ != &::google::protobuf::internal::kEmptyString) {
    delete meta_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
    delete keyfile_;
    delete modify_time_;
    delete change_time_;
  }
}

void FileHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileHeader_descriptor_;
}

const FileHeader& FileHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

FileHeader* FileHeader::default_instance_ = NULL;

FileHeader* FileHeader::New() const {
  return new FileHeader;
}

void FileHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_keyfile()) {
      if (keyfile_ != NULL) keyfile_->::secnfs::KeyFile::Clear();
    }
    if (has_meta()) {
      if (meta_ != &::google::protobuf::internal::kEmptyString) {
        meta_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_modify_time()) {
      if (modify_time_ != NULL) modify_time_->::secnfs::TimeSpec::Clear();
    }
    if (has_change_time()) {
      if (change_time_ != NULL) change_time_->::secnfs::TimeSpec::Clear();
    }
    change_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .secnfs.KeyFile keyfile = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keyfile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_meta;
        break;
      }

      // optional bytes meta = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_meta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_meta()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional bytes version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_modify_time;
        break;
      }

      // optional .secnfs.TimeSpec modify_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_modify_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_modify_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_change_time;
        break;
      }

      // optional .secnfs.TimeSpec change_time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_change_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_change_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_change;
        break;
      }

      // optional uint64 change = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_change:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &change_)));
          set_has_change();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .secnfs.KeyFile keyfile = 1;
  if (has_keyfile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keyfile(), output);
  }

  // optional bytes meta = 2;
  if (has_meta()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->meta(), output);
  }

  // optional bytes version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->version(), output);
  }

  // optional .secnfs.TimeSpec modify_time = 4;
  if (has_modify_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->modify_time(), output);
  }

  // optional .secnfs.TimeSpec change_time = 5;
  if (has_change_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->change_time(), output);
  }

  // optional uint64 change = 6;
  if (has_change()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->change(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .secnfs.KeyFile keyfile = 1;
  if (has_keyfile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keyfile(), target);
  }

  // optional bytes meta = 2;
  if (has_meta()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->meta(), target);
  }

  // optional bytes version = 3;
  if (has_version()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->version(), target);
  }

  // optional .secnfs.TimeSpec modify_time = 4;
  if (has_modify_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->modify_time(), target);
  }

  // optional .secnfs.TimeSpec change_time = 5;
  if (has_change_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->change_time(), target);
  }

  // optional uint64 change = 6;
  if (has_change()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->change(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .secnfs.KeyFile keyfile = 1;
    if (has_keyfile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keyfile());
    }

    // optional bytes meta = 2;
    if (has_meta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->meta());
    }

    // optional bytes version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->version());
    }

    // optional .secnfs.TimeSpec modify_time = 4;
    if (has_modify_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->modify_time());
    }

    // optional .secnfs.TimeSpec change_time = 5;
    if (has_change_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->change_time());
    }

    // optional uint64 change = 6;
    if (has_change()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->change());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileHeader::MergeFrom(const FileHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyfile()) {
      mutable_keyfile()->::secnfs::KeyFile::MergeFrom(from.keyfile());
    }
    if (from.has_meta()) {
      set_meta(from.meta());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_modify_time()) {
      mutable_modify_time()->::secnfs::TimeSpec::MergeFrom(from.modify_time());
    }
    if (from.has_change_time()) {
      mutable_change_time()->::secnfs::TimeSpec::MergeFrom(from.change_time());
    }
    if (from.has_change()) {
      set_change(from.change());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileHeader::CopyFrom(const FileHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_keyfile()) {
    if (!this->keyfile().IsInitialized()) return false;
  }
  if (has_modify_time()) {
    if (!this->modify_time().IsInitialized()) return false;
  }
  if (has_change_time()) {
    if (!this->change_time().IsInitialized()) return false;
  }
  return true;
}

void FileHeader::Swap(FileHeader* other) {
  if (other != this) {
    std::swap(keyfile_, other->keyfile_);
    std::swap(meta_, other->meta_);
    std::swap(version_, other->version_);
    std::swap(modify_time_, other->modify_time_);
    std::swap(change_time_, other->change_time_);
    std::swap(change_, other->change_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileHeader_descriptor_;
  metadata.reflection = FileHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileMeta::kFilesizeFieldNumber;
const int FileMeta::kEncryptedFieldNumber;
const int FileMeta::kHolesFieldNumber;
#endif  // !_MSC_VER

FileMeta::FileMeta()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileMeta::InitAsDefaultInstance() {
}

FileMeta::FileMeta(const FileMeta& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileMeta::SharedCtor() {
  _cached_size_ = 0;
  filesize_ = GOOGLE_ULONGLONG(0);
  encrypted_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileMeta::~FileMeta() {
  SharedDtor();
}

void FileMeta::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FileMeta::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileMeta::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileMeta_descriptor_;
}

const FileMeta& FileMeta::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

FileMeta* FileMeta::default_instance_ = NULL;

FileMeta* FileMeta::New() const {
  return new FileMeta;
}

void FileMeta::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    filesize_ = GOOGLE_ULONGLONG(0);
    encrypted_ = false;
  }
  holes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileMeta::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 filesize = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filesize_)));
          set_has_filesize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_encrypted;
        break;
      }

      // optional bool encrypted = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encrypted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &encrypted_)));
          set_has_encrypted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_holes;
        break;
      }

      // repeated .secnfs.Range holes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_holes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_holes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_holes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileMeta::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 filesize = 1;
  if (has_filesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->filesize(), output);
  }

  // optional bool encrypted = 2;
  if (has_encrypted()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->encrypted(), output);
  }

  // repeated .secnfs.Range holes = 3;
  for (int i = 0; i < this->holes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->holes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileMeta::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 filesize = 1;
  if (has_filesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->filesize(), target);
  }

  // optional bool encrypted = 2;
  if (has_encrypted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->encrypted(), target);
  }

  // repeated .secnfs.Range holes = 3;
  for (int i = 0; i < this->holes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->holes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileMeta::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 filesize = 1;
    if (has_filesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->filesize());
    }

    // optional bool encrypted = 2;
    if (has_encrypted()) {
      total_size += 1 + 1;
    }

  }
  // repeated .secnfs.Range holes = 3;
  total_size += 1 * this->holes_size();
  for (int i = 0; i < this->holes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->holes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileMeta::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileMeta* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileMeta*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileMeta::MergeFrom(const FileMeta& from) {
  GOOGLE_CHECK_NE(&from, this);
  holes_.MergeFrom(from.holes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filesize()) {
      set_filesize(from.filesize());
    }
    if (from.has_encrypted()) {
      set_encrypted(from.encrypted());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileMeta::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileMeta::CopyFrom(const FileMeta& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileMeta::IsInitialized() const {

  for (int i = 0; i < holes_size(); i++) {
    if (!this->holes(i).IsInitialized()) return false;
  }
  return true;
}

void FileMeta::Swap(FileMeta* other) {
  if (other != this) {
    std::swap(filesize_, other->filesize_);
    std::swap(encrypted_, other->encrypted_);
    holes_.Swap(&other->holes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileMeta::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileMeta_descriptor_;
  metadata.reflection = FileMeta_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Range::kOffsetFieldNumber;
const int Range::kLengthFieldNumber;
#endif  // !_MSC_VER

Range::Range()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Range::InitAsDefaultInstance() {
}

Range::Range(const Range& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Range::SharedCtor() {
  _cached_size_ = 0;
  offset_ = GOOGLE_ULONGLONG(0);
  length_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Range::~Range() {
  SharedDtor();
}

void Range::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Range::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Range_descriptor_;
}

const Range& Range::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

Range* Range::default_instance_ = NULL;

Range* Range::New() const {
  return new Range;
}

void Range::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = GOOGLE_ULONGLONG(0);
    length_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_length;
        break;
      }

      // required uint64 length = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->offset(), output);
  }

  // required uint64 length = 2;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->length(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Range::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 offset = 1;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->offset(), target);
  }

  // required uint64 length = 2;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->length(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Range::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // required uint64 length = 2;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->length());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Range::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Range* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Range*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Range::MergeFrom(const Range& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Range::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Range::CopyFrom(const Range& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Range::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Range::Swap(Range* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(length_, other->length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Range::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Range_descriptor_;
  metadata.reflection = Range_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyFile::kCreatorFieldNumber;
const int KeyFile::kIvFieldNumber;
const int KeyFile::kKeyBlocksFieldNumber;
const int KeyFile::kSignatureFieldNumber;
#endif  // !_MSC_VER

KeyFile::KeyFile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyFile::InitAsDefaultInstance() {
}

KeyFile::KeyFile(const KeyFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyFile::SharedCtor() {
  _cached_size_ = 0;
  creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyFile::~KeyFile() {
  SharedDtor();
}

void KeyFile::SharedDtor() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void KeyFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyFile_descriptor_;
}

const KeyFile& KeyFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

KeyFile* KeyFile::default_instance_ = NULL;

KeyFile* KeyFile::New() const {
  return new KeyFile;
}

void KeyFile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_creator()) {
      if (creator_ != &::google::protobuf::internal::kEmptyString) {
        creator_->clear();
      }
    }
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  key_blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string creator = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_creator()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->creator().data(), this->creator().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iv;
        break;
      }

      // required bytes iv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        break;
      }

      // repeated .secnfs.KeyBlock key_blocks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // optional bytes signature = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->creator(), output);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->iv(), output);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->key_blocks(i), output);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->creator(), target);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->iv(), target);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->key_blocks(i), target);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string creator = 1;
    if (has_creator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->creator());
    }

    // required bytes iv = 2;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // optional bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .secnfs.KeyBlock key_blocks = 3;
  total_size += 1 * this->key_blocks_size();
  for (int i = 0; i < this->key_blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyFile::MergeFrom(const KeyFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_blocks_.MergeFrom(from.key_blocks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_creator()) {
      set_creator(from.creator());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyFile::CopyFrom(const KeyFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < key_blocks_size(); i++) {
    if (!this->key_blocks(i).IsInitialized()) return false;
  }
  return true;
}

void KeyFile::Swap(KeyFile* other) {
  if (other != this) {
    std::swap(creator_, other->creator_);
    std::swap(iv_, other->iv_);
    key_blocks_.Swap(&other->key_blocks_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyFile_descriptor_;
  metadata.reflection = KeyFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyBlock::kProxyNameFieldNumber;
const int KeyBlock::kEncryptedKeyFieldNumber;
#endif  // !_MSC_VER

KeyBlock::KeyBlock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyBlock::InitAsDefaultInstance() {
}

KeyBlock::KeyBlock(const KeyBlock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyBlock::SharedCtor() {
  _cached_size_ = 0;
  proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrypted_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyBlock::~KeyBlock() {
  SharedDtor();
}

void KeyBlock::SharedDtor() {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proxy_name_;
  }
  if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_key_;
  }
  if (this != default_instance_) {
  }
}

void KeyBlock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyBlock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyBlock_descriptor_;
}

const KeyBlock& KeyBlock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

KeyBlock* KeyBlock::default_instance_ = NULL;

KeyBlock* KeyBlock::New() const {
  return new KeyBlock;
}

void KeyBlock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_proxy_name()) {
      if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
        proxy_name_->clear();
      }
    }
    if (has_encrypted_key()) {
      if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
        encrypted_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyBlock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string proxy_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_proxy_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->proxy_name().data(), this->proxy_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrypted_key;
        break;
      }

      // required bytes encrypted_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyBlock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string proxy_name = 1;
  if (has_proxy_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proxy_name().data(), this->proxy_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->proxy_name(), output);
  }

  // required bytes encrypted_key = 2;
  if (has_encrypted_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encrypted_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyBlock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string proxy_name = 1;
  if (has_proxy_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proxy_name().data(), this->proxy_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->proxy_name(), target);
  }

  // required bytes encrypted_key = 2;
  if (has_encrypted_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encrypted_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyBlock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string proxy_name = 1;
    if (has_proxy_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->proxy_name());
    }

    // required bytes encrypted_key = 2;
    if (has_encrypted_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyBlock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyBlock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyBlock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyBlock::MergeFrom(const KeyBlock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_proxy_name()) {
      set_proxy_name(from.proxy_name());
    }
    if (from.has_encrypted_key()) {
      set_encrypted_key(from.encrypted_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyBlock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyBlock::CopyFrom(const KeyBlock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyBlock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void KeyBlock::Swap(KeyBlock* other) {
  if (other != this) {
    std::swap(proxy_name_, other->proxy_name_);
    std::swap(encrypted_key_, other->encrypted_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyBlock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyBlock_descriptor_;
  metadata.reflection = KeyBlock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SecureContextConfig::kNameFieldNumber;
const int SecureContextConfig::kPubKeyFieldNumber;
const int SecureContextConfig::kPriKeyFieldNumber;
#endif  // !_MSC_VER

SecureContextConfig::SecureContextConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SecureContextConfig::InitAsDefaultInstance() {
}

SecureContextConfig::SecureContextConfig(const SecureContextConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SecureContextConfig::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pri_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecureContextConfig::~SecureContextConfig() {
  SharedDtor();
}

void SecureContextConfig::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pub_key_;
  }
  if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pri_key_;
  }
  if (this != default_instance_) {
  }
}

void SecureContextConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SecureContextConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SecureContextConfig_descriptor_;
}

const SecureContextConfig& SecureContextConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

SecureContextConfig* SecureContextConfig::default_instance_ = NULL;

SecureContextConfig* SecureContextConfig::New() const {
  return new SecureContextConfig;
}

void SecureContextConfig::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pub_key()) {
      if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
        pub_key_->clear();
      }
    }
    if (has_pri_key()) {
      if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
        pri_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SecureContextConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pub_key;
        break;
      }

      // required bytes pub_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pub_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pub_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pri_key;
        break;
      }

      // required bytes pri_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pri_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pri_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SecureContextConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required bytes pub_key = 2;
  if (has_pub_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->pub_key(), output);
  }

  // required bytes pri_key = 3;
  if (has_pri_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->pri_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SecureContextConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required bytes pub_key = 2;
  if (has_pub_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->pub_key(), target);
  }

  // required bytes pri_key = 3;
  if (has_pri_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pri_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SecureContextConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required bytes pub_key = 2;
    if (has_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pub_key());
    }

    // required bytes pri_key = 3;
    if (has_pri_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pri_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecureContextConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SecureContextConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SecureContextConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SecureContextConfig::MergeFrom(const SecureContextConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pub_key()) {
      set_pub_key(from.pub_key());
    }
    if (from.has_pri_key()) {
      set_pri_key(from.pri_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SecureContextConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SecureContextConfig::CopyFrom(const SecureContextConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecureContextConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SecureContextConfig::Swap(SecureContextConfig* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(pub_key_, other->pub_key_);
    std::swap(pri_key_, other->pri_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SecureContextConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SecureContextConfig_descriptor_;
  metadata.reflection = SecureContextConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProxyList::kProxiesFieldNumber;
#endif  // !_MSC_VER

ProxyList::ProxyList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProxyList::InitAsDefaultInstance() {
}

ProxyList::ProxyList(const ProxyList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProxyList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProxyList::~ProxyList() {
  SharedDtor();
}

void ProxyList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProxyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProxyList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProxyList_descriptor_;
}

const ProxyList& ProxyList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

ProxyList* ProxyList::default_instance_ = NULL;

ProxyList* ProxyList::New() const {
  return new ProxyList;
}

void ProxyList::Clear() {
  proxies_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProxyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .secnfs.ProxyEntry proxies = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_proxies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_proxies()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_proxies;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProxyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .secnfs.ProxyEntry proxies = 1;
  for (int i = 0; i < this->proxies_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->proxies(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProxyList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .secnfs.ProxyEntry proxies = 1;
  for (int i = 0; i < this->proxies_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->proxies(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProxyList::ByteSize() const {
  int total_size = 0;

  // repeated .secnfs.ProxyEntry proxies = 1;
  total_size += 1 * this->proxies_size();
  for (int i = 0; i < this->proxies_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->proxies(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProxyList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProxyList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProxyList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProxyList::MergeFrom(const ProxyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  proxies_.MergeFrom(from.proxies_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProxyList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProxyList::CopyFrom(const ProxyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProxyList::IsInitialized() const {

  for (int i = 0; i < proxies_size(); i++) {
    if (!this->proxies(i).IsInitialized()) return false;
  }
  return true;
}

void ProxyList::Swap(ProxyList* other) {
  if (other != this) {
    proxies_.Swap(&other->proxies_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProxyList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProxyList_descriptor_;
  metadata.reflection = ProxyList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProxyEntry::kNameFieldNumber;
const int ProxyEntry::kKeyFieldNumber;
#endif  // !_MSC_VER

ProxyEntry::ProxyEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProxyEntry::InitAsDefaultInstance() {
}

ProxyEntry::ProxyEntry(const ProxyEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProxyEntry::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProxyEntry::~ProxyEntry() {
  SharedDtor();
}

void ProxyEntry::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void ProxyEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProxyEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProxyEntry_descriptor_;
}

const ProxyEntry& ProxyEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

ProxyEntry* ProxyEntry::default_instance_ = NULL;

ProxyEntry* ProxyEntry::New() const {
  return new ProxyEntry;
}

void ProxyEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProxyEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // required bytes key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProxyEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required bytes key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProxyEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required bytes key = 2;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProxyEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required bytes key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProxyEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProxyEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProxyEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProxyEntry::MergeFrom(const ProxyEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProxyEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProxyEntry::CopyFrom(const ProxyEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProxyEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ProxyEntry::Swap(ProxyEntry* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProxyEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProxyEntry_descriptor_;
  metadata.reflection = ProxyEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FilenameEntry::kEntryIdFieldNumber;
const int FilenameEntry::kEncryptedNameFieldNumber;
#endif  // !_MSC_VER

FilenameEntry::FilenameEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FilenameEntry::InitAsDefaultInstance() {
}

FilenameEntry::FilenameEntry(const FilenameEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FilenameEntry::SharedCtor() {
  _cached_size_ = 0;
  entry_id_ = 0u;
  encrypted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilenameEntry::~FilenameEntry() {
  SharedDtor();
}

void FilenameEntry::SharedDtor() {
  if (encrypted_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_name_;
  }
  if (this != default_instance_) {
  }
}

void FilenameEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilenameEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilenameEntry_descriptor_;
}

const FilenameEntry& FilenameEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

FilenameEntry* FilenameEntry::default_instance_ = NULL;

FilenameEntry* FilenameEntry::New() const {
  return new FilenameEntry;
}

void FilenameEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    entry_id_ = 0u;
    if (has_encrypted_name()) {
      if (encrypted_name_ != &::google::protobuf::internal::kEmptyString) {
        encrypted_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilenameEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 entry_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entry_id_)));
          set_has_entry_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrypted_name;
        break;
      }

      // required bytes encrypted_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilenameEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 entry_id = 1;
  if (has_entry_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->entry_id(), output);
  }

  // required bytes encrypted_name = 2;
  if (has_encrypted_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encrypted_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FilenameEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 entry_id = 1;
  if (has_entry_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->entry_id(), target);
  }

  // required bytes encrypted_name = 2;
  if (has_encrypted_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encrypted_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FilenameEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 entry_id = 1;
    if (has_entry_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entry_id());
    }

    // required bytes encrypted_name = 2;
    if (has_encrypted_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilenameEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilenameEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilenameEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilenameEntry::MergeFrom(const FilenameEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entry_id()) {
      set_entry_id(from.entry_id());
    }
    if (from.has_encrypted_name()) {
      set_encrypted_name(from.encrypted_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilenameEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilenameEntry::CopyFrom(const FilenameEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilenameEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void FilenameEntry::Swap(FilenameEntry* other) {
  if (other != this) {
    std::swap(entry_id_, other->entry_id_);
    std::swap(encrypted_name_, other->encrypted_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilenameEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilenameEntry_descriptor_;
  metadata.reflection = FilenameEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DirMapFile::kCreatorFieldNumber;
const int DirMapFile::kIvFieldNumber;
const int DirMapFile::kKeyBlocksFieldNumber;
const int DirMapFile::kFilenamesFieldNumber;
const int DirMapFile::kSignatureFieldNumber;
#endif  // !_MSC_VER

DirMapFile::DirMapFile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DirMapFile::InitAsDefaultInstance() {
  filenames_ = const_cast< ::secnfs::FilenameEntry*>(&::secnfs::FilenameEntry::default_instance());
}

DirMapFile::DirMapFile(const DirMapFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DirMapFile::SharedCtor() {
  _cached_size_ = 0;
  creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  filenames_ = NULL;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirMapFile::~DirMapFile() {
  SharedDtor();
}

void DirMapFile::SharedDtor() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
    delete filenames_;
  }
}

void DirMapFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DirMapFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DirMapFile_descriptor_;
}

const DirMapFile& DirMapFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_secnfs_2eproto();
  return *default_instance_;
}

DirMapFile* DirMapFile::default_instance_ = NULL;

DirMapFile* DirMapFile::New() const {
  return new DirMapFile;
}

void DirMapFile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_creator()) {
      if (creator_ != &::google::protobuf::internal::kEmptyString) {
        creator_->clear();
      }
    }
    if (has_iv()) {
      if (iv_ != &::google::protobuf::internal::kEmptyString) {
        iv_->clear();
      }
    }
    if (has_filenames()) {
      if (filenames_ != NULL) filenames_->::secnfs::FilenameEntry::Clear();
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  key_blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DirMapFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string creator = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_creator()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->creator().data(), this->creator().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_iv;
        break;
      }

      // required bytes iv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        break;
      }

      // repeated .secnfs.KeyBlock key_blocks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_blocks;
        if (input->ExpectTag(34)) goto parse_filenames;
        break;
      }

      // required .secnfs.FilenameEntry filenames = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filenames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filenames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_signature;
        break;
      }

      // optional bytes signature = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirMapFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->creator(), output);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->iv(), output);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->key_blocks(i), output);
  }

  // required .secnfs.FilenameEntry filenames = 4;
  if (has_filenames()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->filenames(), output);
  }

  // optional bytes signature = 6;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DirMapFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string creator = 1;
  if (has_creator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->creator().data(), this->creator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->creator(), target);
  }

  // required bytes iv = 2;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->iv(), target);
  }

  // repeated .secnfs.KeyBlock key_blocks = 3;
  for (int i = 0; i < this->key_blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->key_blocks(i), target);
  }

  // required .secnfs.FilenameEntry filenames = 4;
  if (has_filenames()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->filenames(), target);
  }

  // optional bytes signature = 6;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DirMapFile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string creator = 1;
    if (has_creator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->creator());
    }

    // required bytes iv = 2;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // required .secnfs.FilenameEntry filenames = 4;
    if (has_filenames()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filenames());
    }

    // optional bytes signature = 6;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  // repeated .secnfs.KeyBlock key_blocks = 3;
  total_size += 1 * this->key_blocks_size();
  for (int i = 0; i < this->key_blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key_blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirMapFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DirMapFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DirMapFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DirMapFile::MergeFrom(const DirMapFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_blocks_.MergeFrom(from.key_blocks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_creator()) {
      set_creator(from.creator());
    }
    if (from.has_iv()) {
      set_iv(from.iv());
    }
    if (from.has_filenames()) {
      mutable_filenames()->::secnfs::FilenameEntry::MergeFrom(from.filenames());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DirMapFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DirMapFile::CopyFrom(const DirMapFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirMapFile::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  for (int i = 0; i < key_blocks_size(); i++) {
    if (!this->key_blocks(i).IsInitialized()) return false;
  }
  if (has_filenames()) {
    if (!this->filenames().IsInitialized()) return false;
  }
  return true;
}

void DirMapFile::Swap(DirMapFile* other) {
  if (other != this) {
    std::swap(creator_, other->creator_);
    std::swap(iv_, other->iv_);
    key_blocks_.Swap(&other->key_blocks_);
    std::swap(filenames_, other->filenames_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DirMapFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DirMapFile_descriptor_;
  metadata.reflection = DirMapFile_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace secnfs

// @@protoc_insertion_point(global_scope)
