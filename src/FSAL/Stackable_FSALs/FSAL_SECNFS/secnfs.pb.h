/*
 * Copyright (c) 2013-2018 Ming Chen
 * Copyright (c) 2016-2016 Praveen Kumar Morampudi
 * Copyright (c) 2016-2016 Harshkumar Patel
 * Copyright (c) 2017-2017 Rushabh Shah
 * Copyright (c) 2013-2014 Arun Olappamanna Vasudevan
 * Copyright (c) 2013-2014 Kelong Wang
 * Copyright (c) 2013-2018 Erez Zadok
 * Copyright (c) 2013-2018 Stony Brook University
 * Copyright (c) 2013-2018 The Research Foundation for SUNY
 * This file is released under the GPL.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: secnfs.proto

#ifndef PROTOBUF_secnfs_2eproto__INCLUDED
#define PROTOBUF_secnfs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace secnfs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_secnfs_2eproto();
void protobuf_AssignDesc_secnfs_2eproto();
void protobuf_ShutdownFile_secnfs_2eproto();

class TimeSpec;
class FileHeader;
class FileMeta;
class Range;
class KeyFile;
class KeyBlock;
class SecureContextConfig;
class ProxyList;
class ProxyEntry;
class FilenameEntry;
class DirMapFile;

// ===================================================================

class TimeSpec : public ::google::protobuf::Message {
 public:
  TimeSpec();
  virtual ~TimeSpec();

  TimeSpec(const TimeSpec& from);

  inline TimeSpec& operator=(const TimeSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSpec& default_instance();

  void Swap(TimeSpec* other);

  // implements Message ----------------------------------------------

  TimeSpec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSpec& from);
  void MergeFrom(const TimeSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seconds = 1;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::uint64 seconds() const;
  inline void set_seconds(::google::protobuf::uint64 value);

  // required uint64 nano_seconds = 2;
  inline bool has_nano_seconds() const;
  inline void clear_nano_seconds();
  static const int kNanoSecondsFieldNumber = 2;
  inline ::google::protobuf::uint64 nano_seconds() const;
  inline void set_nano_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:secnfs.TimeSpec)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_nano_seconds();
  inline void clear_has_nano_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint64 nano_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static TimeSpec* default_instance_;
};
// -------------------------------------------------------------------

class FileHeader : public ::google::protobuf::Message {
 public:
  FileHeader();
  virtual ~FileHeader();

  FileHeader(const FileHeader& from);

  inline FileHeader& operator=(const FileHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileHeader& default_instance();

  void Swap(FileHeader* other);

  // implements Message ----------------------------------------------

  FileHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileHeader& from);
  void MergeFrom(const FileHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .secnfs.KeyFile keyfile = 1;
  inline bool has_keyfile() const;
  inline void clear_keyfile();
  static const int kKeyfileFieldNumber = 1;
  inline const ::secnfs::KeyFile& keyfile() const;
  inline ::secnfs::KeyFile* mutable_keyfile();
  inline ::secnfs::KeyFile* release_keyfile();
  inline void set_allocated_keyfile(::secnfs::KeyFile* keyfile);

  // optional bytes meta = 2;
  inline bool has_meta() const;
  inline void clear_meta();
  static const int kMetaFieldNumber = 2;
  inline const ::std::string& meta() const;
  inline void set_meta(const ::std::string& value);
  inline void set_meta(const char* value);
  inline void set_meta(const void* value, size_t size);
  inline ::std::string* mutable_meta();
  inline ::std::string* release_meta();
  inline void set_allocated_meta(::std::string* meta);

  // optional bytes version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .secnfs.TimeSpec modify_time = 4;
  inline bool has_modify_time() const;
  inline void clear_modify_time();
  static const int kModifyTimeFieldNumber = 4;
  inline const ::secnfs::TimeSpec& modify_time() const;
  inline ::secnfs::TimeSpec* mutable_modify_time();
  inline ::secnfs::TimeSpec* release_modify_time();
  inline void set_allocated_modify_time(::secnfs::TimeSpec* modify_time);

  // optional .secnfs.TimeSpec change_time = 5;
  inline bool has_change_time() const;
  inline void clear_change_time();
  static const int kChangeTimeFieldNumber = 5;
  inline const ::secnfs::TimeSpec& change_time() const;
  inline ::secnfs::TimeSpec* mutable_change_time();
  inline ::secnfs::TimeSpec* release_change_time();
  inline void set_allocated_change_time(::secnfs::TimeSpec* change_time);

  // optional uint64 change = 6;
  inline bool has_change() const;
  inline void clear_change();
  static const int kChangeFieldNumber = 6;
  inline ::google::protobuf::uint64 change() const;
  inline void set_change(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:secnfs.FileHeader)
 private:
  inline void set_has_keyfile();
  inline void clear_has_keyfile();
  inline void set_has_meta();
  inline void clear_has_meta();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_modify_time();
  inline void clear_has_modify_time();
  inline void set_has_change_time();
  inline void clear_has_change_time();
  inline void set_has_change();
  inline void clear_has_change();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::secnfs::KeyFile* keyfile_;
  ::std::string* meta_;
  ::std::string* version_;
  ::secnfs::TimeSpec* modify_time_;
  ::secnfs::TimeSpec* change_time_;
  ::google::protobuf::uint64 change_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static FileHeader* default_instance_;
};
// -------------------------------------------------------------------

class FileMeta : public ::google::protobuf::Message {
 public:
  FileMeta();
  virtual ~FileMeta();

  FileMeta(const FileMeta& from);

  inline FileMeta& operator=(const FileMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileMeta& default_instance();

  void Swap(FileMeta* other);

  // implements Message ----------------------------------------------

  FileMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileMeta& from);
  void MergeFrom(const FileMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 filesize = 1;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 1;
  inline ::google::protobuf::uint64 filesize() const;
  inline void set_filesize(::google::protobuf::uint64 value);

  // optional bool encrypted = 2;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 2;
  inline bool encrypted() const;
  inline void set_encrypted(bool value);

  // repeated .secnfs.Range holes = 3;
  inline int holes_size() const;
  inline void clear_holes();
  static const int kHolesFieldNumber = 3;
  inline const ::secnfs::Range& holes(int index) const;
  inline ::secnfs::Range* mutable_holes(int index);
  inline ::secnfs::Range* add_holes();
  inline const ::google::protobuf::RepeatedPtrField< ::secnfs::Range >&
      holes() const;
  inline ::google::protobuf::RepeatedPtrField< ::secnfs::Range >*
      mutable_holes();

  // @@protoc_insertion_point(class_scope:secnfs.FileMeta)
 private:
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_encrypted();
  inline void clear_has_encrypted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 filesize_;
  ::google::protobuf::RepeatedPtrField< ::secnfs::Range > holes_;
  bool encrypted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static FileMeta* default_instance_;
};
// -------------------------------------------------------------------

class Range : public ::google::protobuf::Message {
 public:
  Range();
  virtual ~Range();

  Range(const Range& from);

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Range& default_instance();

  void Swap(Range* other);

  // implements Message ----------------------------------------------

  Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // required uint64 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:secnfs.Range)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static Range* default_instance_;
};
// -------------------------------------------------------------------

class KeyFile : public ::google::protobuf::Message {
 public:
  KeyFile();
  virtual ~KeyFile();

  KeyFile(const KeyFile& from);

  inline KeyFile& operator=(const KeyFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyFile& default_instance();

  void Swap(KeyFile* other);

  // implements Message ----------------------------------------------

  KeyFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyFile& from);
  void MergeFrom(const KeyFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string creator = 1;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 1;
  inline const ::std::string& creator() const;
  inline void set_creator(const ::std::string& value);
  inline void set_creator(const char* value);
  inline void set_creator(const char* value, size_t size);
  inline ::std::string* mutable_creator();
  inline ::std::string* release_creator();
  inline void set_allocated_creator(::std::string* creator);

  // required bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // repeated .secnfs.KeyBlock key_blocks = 3;
  inline int key_blocks_size() const;
  inline void clear_key_blocks();
  static const int kKeyBlocksFieldNumber = 3;
  inline const ::secnfs::KeyBlock& key_blocks(int index) const;
  inline ::secnfs::KeyBlock* mutable_key_blocks(int index);
  inline ::secnfs::KeyBlock* add_key_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >&
      key_blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >*
      mutable_key_blocks();

  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:secnfs.KeyFile)
 private:
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* creator_;
  ::std::string* iv_;
  ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock > key_blocks_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static KeyFile* default_instance_;
};
// -------------------------------------------------------------------

class KeyBlock : public ::google::protobuf::Message {
 public:
  KeyBlock();
  virtual ~KeyBlock();

  KeyBlock(const KeyBlock& from);

  inline KeyBlock& operator=(const KeyBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyBlock& default_instance();

  void Swap(KeyBlock* other);

  // implements Message ----------------------------------------------

  KeyBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyBlock& from);
  void MergeFrom(const KeyBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string proxy_name = 1;
  inline bool has_proxy_name() const;
  inline void clear_proxy_name();
  static const int kProxyNameFieldNumber = 1;
  inline const ::std::string& proxy_name() const;
  inline void set_proxy_name(const ::std::string& value);
  inline void set_proxy_name(const char* value);
  inline void set_proxy_name(const char* value, size_t size);
  inline ::std::string* mutable_proxy_name();
  inline ::std::string* release_proxy_name();
  inline void set_allocated_proxy_name(::std::string* proxy_name);

  // required bytes encrypted_key = 2;
  inline bool has_encrypted_key() const;
  inline void clear_encrypted_key();
  static const int kEncryptedKeyFieldNumber = 2;
  inline const ::std::string& encrypted_key() const;
  inline void set_encrypted_key(const ::std::string& value);
  inline void set_encrypted_key(const char* value);
  inline void set_encrypted_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_key();
  inline ::std::string* release_encrypted_key();
  inline void set_allocated_encrypted_key(::std::string* encrypted_key);

  // @@protoc_insertion_point(class_scope:secnfs.KeyBlock)
 private:
  inline void set_has_proxy_name();
  inline void clear_has_proxy_name();
  inline void set_has_encrypted_key();
  inline void clear_has_encrypted_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* proxy_name_;
  ::std::string* encrypted_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static KeyBlock* default_instance_;
};
// -------------------------------------------------------------------

class SecureContextConfig : public ::google::protobuf::Message {
 public:
  SecureContextConfig();
  virtual ~SecureContextConfig();

  SecureContextConfig(const SecureContextConfig& from);

  inline SecureContextConfig& operator=(const SecureContextConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecureContextConfig& default_instance();

  void Swap(SecureContextConfig* other);

  // implements Message ----------------------------------------------

  SecureContextConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecureContextConfig& from);
  void MergeFrom(const SecureContextConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes pub_key = 2;
  inline bool has_pub_key() const;
  inline void clear_pub_key();
  static const int kPubKeyFieldNumber = 2;
  inline const ::std::string& pub_key() const;
  inline void set_pub_key(const ::std::string& value);
  inline void set_pub_key(const char* value);
  inline void set_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_pub_key();
  inline ::std::string* release_pub_key();
  inline void set_allocated_pub_key(::std::string* pub_key);

  // required bytes pri_key = 3;
  inline bool has_pri_key() const;
  inline void clear_pri_key();
  static const int kPriKeyFieldNumber = 3;
  inline const ::std::string& pri_key() const;
  inline void set_pri_key(const ::std::string& value);
  inline void set_pri_key(const char* value);
  inline void set_pri_key(const void* value, size_t size);
  inline ::std::string* mutable_pri_key();
  inline ::std::string* release_pri_key();
  inline void set_allocated_pri_key(::std::string* pri_key);

  // @@protoc_insertion_point(class_scope:secnfs.SecureContextConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pub_key();
  inline void clear_has_pub_key();
  inline void set_has_pri_key();
  inline void clear_has_pri_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* pub_key_;
  ::std::string* pri_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static SecureContextConfig* default_instance_;
};
// -------------------------------------------------------------------

class ProxyList : public ::google::protobuf::Message {
 public:
  ProxyList();
  virtual ~ProxyList();

  ProxyList(const ProxyList& from);

  inline ProxyList& operator=(const ProxyList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyList& default_instance();

  void Swap(ProxyList* other);

  // implements Message ----------------------------------------------

  ProxyList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProxyList& from);
  void MergeFrom(const ProxyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .secnfs.ProxyEntry proxies = 1;
  inline int proxies_size() const;
  inline void clear_proxies();
  static const int kProxiesFieldNumber = 1;
  inline const ::secnfs::ProxyEntry& proxies(int index) const;
  inline ::secnfs::ProxyEntry* mutable_proxies(int index);
  inline ::secnfs::ProxyEntry* add_proxies();
  inline const ::google::protobuf::RepeatedPtrField< ::secnfs::ProxyEntry >&
      proxies() const;
  inline ::google::protobuf::RepeatedPtrField< ::secnfs::ProxyEntry >*
      mutable_proxies();

  // @@protoc_insertion_point(class_scope:secnfs.ProxyList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::secnfs::ProxyEntry > proxies_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static ProxyList* default_instance_;
};
// -------------------------------------------------------------------

class ProxyEntry : public ::google::protobuf::Message {
 public:
  ProxyEntry();
  virtual ~ProxyEntry();

  ProxyEntry(const ProxyEntry& from);

  inline ProxyEntry& operator=(const ProxyEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyEntry& default_instance();

  void Swap(ProxyEntry* other);

  // implements Message ----------------------------------------------

  ProxyEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProxyEntry& from);
  void MergeFrom(const ProxyEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:secnfs.ProxyEntry)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static ProxyEntry* default_instance_;
};
// -------------------------------------------------------------------

class FilenameEntry : public ::google::protobuf::Message {
 public:
  FilenameEntry();
  virtual ~FilenameEntry();

  FilenameEntry(const FilenameEntry& from);

  inline FilenameEntry& operator=(const FilenameEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilenameEntry& default_instance();

  void Swap(FilenameEntry* other);

  // implements Message ----------------------------------------------

  FilenameEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilenameEntry& from);
  void MergeFrom(const FilenameEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 entry_id = 1;
  inline bool has_entry_id() const;
  inline void clear_entry_id();
  static const int kEntryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 entry_id() const;
  inline void set_entry_id(::google::protobuf::uint32 value);

  // required bytes encrypted_name = 2;
  inline bool has_encrypted_name() const;
  inline void clear_encrypted_name();
  static const int kEncryptedNameFieldNumber = 2;
  inline const ::std::string& encrypted_name() const;
  inline void set_encrypted_name(const ::std::string& value);
  inline void set_encrypted_name(const char* value);
  inline void set_encrypted_name(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_name();
  inline ::std::string* release_encrypted_name();
  inline void set_allocated_encrypted_name(::std::string* encrypted_name);

  // @@protoc_insertion_point(class_scope:secnfs.FilenameEntry)
 private:
  inline void set_has_entry_id();
  inline void clear_has_entry_id();
  inline void set_has_encrypted_name();
  inline void clear_has_encrypted_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encrypted_name_;
  ::google::protobuf::uint32 entry_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static FilenameEntry* default_instance_;
};
// -------------------------------------------------------------------

class DirMapFile : public ::google::protobuf::Message {
 public:
  DirMapFile();
  virtual ~DirMapFile();

  DirMapFile(const DirMapFile& from);

  inline DirMapFile& operator=(const DirMapFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirMapFile& default_instance();

  void Swap(DirMapFile* other);

  // implements Message ----------------------------------------------

  DirMapFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirMapFile& from);
  void MergeFrom(const DirMapFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string creator = 1;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 1;
  inline const ::std::string& creator() const;
  inline void set_creator(const ::std::string& value);
  inline void set_creator(const char* value);
  inline void set_creator(const char* value, size_t size);
  inline ::std::string* mutable_creator();
  inline ::std::string* release_creator();
  inline void set_allocated_creator(::std::string* creator);

  // required bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // repeated .secnfs.KeyBlock key_blocks = 3;
  inline int key_blocks_size() const;
  inline void clear_key_blocks();
  static const int kKeyBlocksFieldNumber = 3;
  inline const ::secnfs::KeyBlock& key_blocks(int index) const;
  inline ::secnfs::KeyBlock* mutable_key_blocks(int index);
  inline ::secnfs::KeyBlock* add_key_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >&
      key_blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >*
      mutable_key_blocks();

  // required .secnfs.FilenameEntry filenames = 4;
  inline bool has_filenames() const;
  inline void clear_filenames();
  static const int kFilenamesFieldNumber = 4;
  inline const ::secnfs::FilenameEntry& filenames() const;
  inline ::secnfs::FilenameEntry* mutable_filenames();
  inline ::secnfs::FilenameEntry* release_filenames();
  inline void set_allocated_filenames(::secnfs::FilenameEntry* filenames);

  // optional bytes signature = 6;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 6;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:secnfs.DirMapFile)
 private:
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_filenames();
  inline void clear_has_filenames();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* creator_;
  ::std::string* iv_;
  ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock > key_blocks_;
  ::secnfs::FilenameEntry* filenames_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_secnfs_2eproto();
  friend void protobuf_AssignDesc_secnfs_2eproto();
  friend void protobuf_ShutdownFile_secnfs_2eproto();

  void InitAsDefaultInstance();
  static DirMapFile* default_instance_;
};
// ===================================================================


// ===================================================================

// TimeSpec

// required uint64 seconds = 1;
inline bool TimeSpec::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeSpec::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeSpec::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeSpec::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::uint64 TimeSpec::seconds() const {
  return seconds_;
}
inline void TimeSpec::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
}

// required uint64 nano_seconds = 2;
inline bool TimeSpec::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeSpec::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeSpec::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeSpec::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
inline ::google::protobuf::uint64 TimeSpec::nano_seconds() const {
  return nano_seconds_;
}
inline void TimeSpec::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
}

// -------------------------------------------------------------------

// FileHeader

// required .secnfs.KeyFile keyfile = 1;
inline bool FileHeader::has_keyfile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileHeader::set_has_keyfile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileHeader::clear_has_keyfile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileHeader::clear_keyfile() {
  if (keyfile_ != NULL) keyfile_->::secnfs::KeyFile::Clear();
  clear_has_keyfile();
}
inline const ::secnfs::KeyFile& FileHeader::keyfile() const {
  return keyfile_ != NULL ? *keyfile_ : *default_instance_->keyfile_;
}
inline ::secnfs::KeyFile* FileHeader::mutable_keyfile() {
  set_has_keyfile();
  if (keyfile_ == NULL) keyfile_ = new ::secnfs::KeyFile;
  return keyfile_;
}
inline ::secnfs::KeyFile* FileHeader::release_keyfile() {
  clear_has_keyfile();
  ::secnfs::KeyFile* temp = keyfile_;
  keyfile_ = NULL;
  return temp;
}
inline void FileHeader::set_allocated_keyfile(::secnfs::KeyFile* keyfile) {
  delete keyfile_;
  keyfile_ = keyfile;
  if (keyfile) {
    set_has_keyfile();
  } else {
    clear_has_keyfile();
  }
}

// optional bytes meta = 2;
inline bool FileHeader::has_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileHeader::set_has_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileHeader::clear_has_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileHeader::clear_meta() {
  if (meta_ != &::google::protobuf::internal::kEmptyString) {
    meta_->clear();
  }
  clear_has_meta();
}
inline const ::std::string& FileHeader::meta() const {
  return *meta_;
}
inline void FileHeader::set_meta(const ::std::string& value) {
  set_has_meta();
  if (meta_ == &::google::protobuf::internal::kEmptyString) {
    meta_ = new ::std::string;
  }
  meta_->assign(value);
}
inline void FileHeader::set_meta(const char* value) {
  set_has_meta();
  if (meta_ == &::google::protobuf::internal::kEmptyString) {
    meta_ = new ::std::string;
  }
  meta_->assign(value);
}
inline void FileHeader::set_meta(const void* value, size_t size) {
  set_has_meta();
  if (meta_ == &::google::protobuf::internal::kEmptyString) {
    meta_ = new ::std::string;
  }
  meta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileHeader::mutable_meta() {
  set_has_meta();
  if (meta_ == &::google::protobuf::internal::kEmptyString) {
    meta_ = new ::std::string;
  }
  return meta_;
}
inline ::std::string* FileHeader::release_meta() {
  clear_has_meta();
  if (meta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meta_;
    meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileHeader::set_allocated_meta(::std::string* meta) {
  if (meta_ != &::google::protobuf::internal::kEmptyString) {
    delete meta_;
  }
  if (meta) {
    set_has_meta();
    meta_ = meta;
  } else {
    clear_has_meta();
    meta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes version = 3;
inline bool FileHeader::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileHeader::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileHeader::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& FileHeader::version() const {
  return *version_;
}
inline void FileHeader::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FileHeader::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void FileHeader::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileHeader::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* FileHeader::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileHeader::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .secnfs.TimeSpec modify_time = 4;
inline bool FileHeader::has_modify_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileHeader::set_has_modify_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileHeader::clear_has_modify_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileHeader::clear_modify_time() {
  if (modify_time_ != NULL) modify_time_->::secnfs::TimeSpec::Clear();
  clear_has_modify_time();
}
inline const ::secnfs::TimeSpec& FileHeader::modify_time() const {
  return modify_time_ != NULL ? *modify_time_ : *default_instance_->modify_time_;
}
inline ::secnfs::TimeSpec* FileHeader::mutable_modify_time() {
  set_has_modify_time();
  if (modify_time_ == NULL) modify_time_ = new ::secnfs::TimeSpec;
  return modify_time_;
}
inline ::secnfs::TimeSpec* FileHeader::release_modify_time() {
  clear_has_modify_time();
  ::secnfs::TimeSpec* temp = modify_time_;
  modify_time_ = NULL;
  return temp;
}
inline void FileHeader::set_allocated_modify_time(::secnfs::TimeSpec* modify_time) {
  delete modify_time_;
  modify_time_ = modify_time;
  if (modify_time) {
    set_has_modify_time();
  } else {
    clear_has_modify_time();
  }
}

// optional .secnfs.TimeSpec change_time = 5;
inline bool FileHeader::has_change_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileHeader::set_has_change_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileHeader::clear_has_change_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileHeader::clear_change_time() {
  if (change_time_ != NULL) change_time_->::secnfs::TimeSpec::Clear();
  clear_has_change_time();
}
inline const ::secnfs::TimeSpec& FileHeader::change_time() const {
  return change_time_ != NULL ? *change_time_ : *default_instance_->change_time_;
}
inline ::secnfs::TimeSpec* FileHeader::mutable_change_time() {
  set_has_change_time();
  if (change_time_ == NULL) change_time_ = new ::secnfs::TimeSpec;
  return change_time_;
}
inline ::secnfs::TimeSpec* FileHeader::release_change_time() {
  clear_has_change_time();
  ::secnfs::TimeSpec* temp = change_time_;
  change_time_ = NULL;
  return temp;
}
inline void FileHeader::set_allocated_change_time(::secnfs::TimeSpec* change_time) {
  delete change_time_;
  change_time_ = change_time;
  if (change_time) {
    set_has_change_time();
  } else {
    clear_has_change_time();
  }
}

// optional uint64 change = 6;
inline bool FileHeader::has_change() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileHeader::set_has_change() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileHeader::clear_has_change() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileHeader::clear_change() {
  change_ = GOOGLE_ULONGLONG(0);
  clear_has_change();
}
inline ::google::protobuf::uint64 FileHeader::change() const {
  return change_;
}
inline void FileHeader::set_change(::google::protobuf::uint64 value) {
  set_has_change();
  change_ = value;
}

// -------------------------------------------------------------------

// FileMeta

// optional uint64 filesize = 1;
inline bool FileMeta::has_filesize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileMeta::set_has_filesize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileMeta::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileMeta::clear_filesize() {
  filesize_ = GOOGLE_ULONGLONG(0);
  clear_has_filesize();
}
inline ::google::protobuf::uint64 FileMeta::filesize() const {
  return filesize_;
}
inline void FileMeta::set_filesize(::google::protobuf::uint64 value) {
  set_has_filesize();
  filesize_ = value;
}

// optional bool encrypted = 2;
inline bool FileMeta::has_encrypted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileMeta::set_has_encrypted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileMeta::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileMeta::clear_encrypted() {
  encrypted_ = false;
  clear_has_encrypted();
}
inline bool FileMeta::encrypted() const {
  return encrypted_;
}
inline void FileMeta::set_encrypted(bool value) {
  set_has_encrypted();
  encrypted_ = value;
}

// repeated .secnfs.Range holes = 3;
inline int FileMeta::holes_size() const {
  return holes_.size();
}
inline void FileMeta::clear_holes() {
  holes_.Clear();
}
inline const ::secnfs::Range& FileMeta::holes(int index) const {
  return holes_.Get(index);
}
inline ::secnfs::Range* FileMeta::mutable_holes(int index) {
  return holes_.Mutable(index);
}
inline ::secnfs::Range* FileMeta::add_holes() {
  return holes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::secnfs::Range >&
FileMeta::holes() const {
  return holes_;
}
inline ::google::protobuf::RepeatedPtrField< ::secnfs::Range >*
FileMeta::mutable_holes() {
  return &holes_;
}

// -------------------------------------------------------------------

// Range

// required uint64 offset = 1;
inline bool Range::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Range::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Range::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Range::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Range::offset() const {
  return offset_;
}
inline void Range::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
}

// required uint64 length = 2;
inline bool Range::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Range::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Range::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Range::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 Range::length() const {
  return length_;
}
inline void Range::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// KeyFile

// required string creator = 1;
inline bool KeyFile::has_creator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyFile::set_has_creator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyFile::clear_has_creator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyFile::clear_creator() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    creator_->clear();
  }
  clear_has_creator();
}
inline const ::std::string& KeyFile::creator() const {
  return *creator_;
}
inline void KeyFile::set_creator(const ::std::string& value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void KeyFile::set_creator(const char* value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void KeyFile::set_creator(const char* value, size_t size) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyFile::mutable_creator() {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  return creator_;
}
inline ::std::string* KeyFile::release_creator() {
  clear_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_;
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyFile::set_allocated_creator(::std::string* creator) {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (creator) {
    set_has_creator();
    creator_ = creator;
  } else {
    clear_has_creator();
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes iv = 2;
inline bool KeyFile::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyFile::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyFile::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyFile::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& KeyFile::iv() const {
  return *iv_;
}
inline void KeyFile::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void KeyFile::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void KeyFile::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyFile::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* KeyFile::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyFile::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .secnfs.KeyBlock key_blocks = 3;
inline int KeyFile::key_blocks_size() const {
  return key_blocks_.size();
}
inline void KeyFile::clear_key_blocks() {
  key_blocks_.Clear();
}
inline const ::secnfs::KeyBlock& KeyFile::key_blocks(int index) const {
  return key_blocks_.Get(index);
}
inline ::secnfs::KeyBlock* KeyFile::mutable_key_blocks(int index) {
  return key_blocks_.Mutable(index);
}
inline ::secnfs::KeyBlock* KeyFile::add_key_blocks() {
  return key_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >&
KeyFile::key_blocks() const {
  return key_blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >*
KeyFile::mutable_key_blocks() {
  return &key_blocks_;
}

// optional bytes signature = 4;
inline bool KeyFile::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyFile::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyFile::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyFile::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& KeyFile::signature() const {
  return *signature_;
}
inline void KeyFile::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void KeyFile::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void KeyFile::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyFile::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* KeyFile::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyFile::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KeyBlock

// required string proxy_name = 1;
inline bool KeyBlock::has_proxy_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyBlock::set_has_proxy_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyBlock::clear_has_proxy_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyBlock::clear_proxy_name() {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    proxy_name_->clear();
  }
  clear_has_proxy_name();
}
inline const ::std::string& KeyBlock::proxy_name() const {
  return *proxy_name_;
}
inline void KeyBlock::set_proxy_name(const ::std::string& value) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(value);
}
inline void KeyBlock::set_proxy_name(const char* value) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(value);
}
inline void KeyBlock::set_proxy_name(const char* value, size_t size) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyBlock::mutable_proxy_name() {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  return proxy_name_;
}
inline ::std::string* KeyBlock::release_proxy_name() {
  clear_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxy_name_;
    proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyBlock::set_allocated_proxy_name(::std::string* proxy_name) {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proxy_name_;
  }
  if (proxy_name) {
    set_has_proxy_name();
    proxy_name_ = proxy_name;
  } else {
    clear_has_proxy_name();
    proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes encrypted_key = 2;
inline bool KeyBlock::has_encrypted_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyBlock::set_has_encrypted_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyBlock::clear_has_encrypted_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyBlock::clear_encrypted_key() {
  if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_key_->clear();
  }
  clear_has_encrypted_key();
}
inline const ::std::string& KeyBlock::encrypted_key() const {
  return *encrypted_key_;
}
inline void KeyBlock::set_encrypted_key(const ::std::string& value) {
  set_has_encrypted_key();
  if (encrypted_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(value);
}
inline void KeyBlock::set_encrypted_key(const char* value) {
  set_has_encrypted_key();
  if (encrypted_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(value);
}
inline void KeyBlock::set_encrypted_key(const void* value, size_t size) {
  set_has_encrypted_key();
  if (encrypted_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyBlock::mutable_encrypted_key() {
  set_has_encrypted_key();
  if (encrypted_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_key_ = new ::std::string;
  }
  return encrypted_key_;
}
inline ::std::string* KeyBlock::release_encrypted_key() {
  clear_has_encrypted_key();
  if (encrypted_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_key_;
    encrypted_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyBlock::set_allocated_encrypted_key(::std::string* encrypted_key) {
  if (encrypted_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_key_;
  }
  if (encrypted_key) {
    set_has_encrypted_key();
    encrypted_key_ = encrypted_key;
  } else {
    clear_has_encrypted_key();
    encrypted_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SecureContextConfig

// required string name = 1;
inline bool SecureContextConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecureContextConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecureContextConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecureContextConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SecureContextConfig::name() const {
  return *name_;
}
inline void SecureContextConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SecureContextConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SecureContextConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureContextConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SecureContextConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecureContextConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes pub_key = 2;
inline bool SecureContextConfig::has_pub_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecureContextConfig::set_has_pub_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecureContextConfig::clear_has_pub_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecureContextConfig::clear_pub_key() {
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    pub_key_->clear();
  }
  clear_has_pub_key();
}
inline const ::std::string& SecureContextConfig::pub_key() const {
  return *pub_key_;
}
inline void SecureContextConfig::set_pub_key(const ::std::string& value) {
  set_has_pub_key();
  if (pub_key_ == &::google::protobuf::internal::kEmptyString) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(value);
}
inline void SecureContextConfig::set_pub_key(const char* value) {
  set_has_pub_key();
  if (pub_key_ == &::google::protobuf::internal::kEmptyString) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(value);
}
inline void SecureContextConfig::set_pub_key(const void* value, size_t size) {
  set_has_pub_key();
  if (pub_key_ == &::google::protobuf::internal::kEmptyString) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureContextConfig::mutable_pub_key() {
  set_has_pub_key();
  if (pub_key_ == &::google::protobuf::internal::kEmptyString) {
    pub_key_ = new ::std::string;
  }
  return pub_key_;
}
inline ::std::string* SecureContextConfig::release_pub_key() {
  clear_has_pub_key();
  if (pub_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pub_key_;
    pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecureContextConfig::set_allocated_pub_key(::std::string* pub_key) {
  if (pub_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pub_key_;
  }
  if (pub_key) {
    set_has_pub_key();
    pub_key_ = pub_key;
  } else {
    clear_has_pub_key();
    pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes pri_key = 3;
inline bool SecureContextConfig::has_pri_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecureContextConfig::set_has_pri_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecureContextConfig::clear_has_pri_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecureContextConfig::clear_pri_key() {
  if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
    pri_key_->clear();
  }
  clear_has_pri_key();
}
inline const ::std::string& SecureContextConfig::pri_key() const {
  return *pri_key_;
}
inline void SecureContextConfig::set_pri_key(const ::std::string& value) {
  set_has_pri_key();
  if (pri_key_ == &::google::protobuf::internal::kEmptyString) {
    pri_key_ = new ::std::string;
  }
  pri_key_->assign(value);
}
inline void SecureContextConfig::set_pri_key(const char* value) {
  set_has_pri_key();
  if (pri_key_ == &::google::protobuf::internal::kEmptyString) {
    pri_key_ = new ::std::string;
  }
  pri_key_->assign(value);
}
inline void SecureContextConfig::set_pri_key(const void* value, size_t size) {
  set_has_pri_key();
  if (pri_key_ == &::google::protobuf::internal::kEmptyString) {
    pri_key_ = new ::std::string;
  }
  pri_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureContextConfig::mutable_pri_key() {
  set_has_pri_key();
  if (pri_key_ == &::google::protobuf::internal::kEmptyString) {
    pri_key_ = new ::std::string;
  }
  return pri_key_;
}
inline ::std::string* SecureContextConfig::release_pri_key() {
  clear_has_pri_key();
  if (pri_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pri_key_;
    pri_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecureContextConfig::set_allocated_pri_key(::std::string* pri_key) {
  if (pri_key_ != &::google::protobuf::internal::kEmptyString) {
    delete pri_key_;
  }
  if (pri_key) {
    set_has_pri_key();
    pri_key_ = pri_key;
  } else {
    clear_has_pri_key();
    pri_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProxyList

// repeated .secnfs.ProxyEntry proxies = 1;
inline int ProxyList::proxies_size() const {
  return proxies_.size();
}
inline void ProxyList::clear_proxies() {
  proxies_.Clear();
}
inline const ::secnfs::ProxyEntry& ProxyList::proxies(int index) const {
  return proxies_.Get(index);
}
inline ::secnfs::ProxyEntry* ProxyList::mutable_proxies(int index) {
  return proxies_.Mutable(index);
}
inline ::secnfs::ProxyEntry* ProxyList::add_proxies() {
  return proxies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::secnfs::ProxyEntry >&
ProxyList::proxies() const {
  return proxies_;
}
inline ::google::protobuf::RepeatedPtrField< ::secnfs::ProxyEntry >*
ProxyList::mutable_proxies() {
  return &proxies_;
}

// -------------------------------------------------------------------

// ProxyEntry

// required string name = 1;
inline bool ProxyEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProxyEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProxyEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProxyEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProxyEntry::name() const {
  return *name_;
}
inline void ProxyEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProxyEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProxyEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProxyEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProxyEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProxyEntry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes key = 2;
inline bool ProxyEntry::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProxyEntry::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProxyEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProxyEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ProxyEntry::key() const {
  return *key_;
}
inline void ProxyEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProxyEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ProxyEntry::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProxyEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ProxyEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProxyEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FilenameEntry

// required uint32 entry_id = 1;
inline bool FilenameEntry::has_entry_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilenameEntry::set_has_entry_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilenameEntry::clear_has_entry_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilenameEntry::clear_entry_id() {
  entry_id_ = 0u;
  clear_has_entry_id();
}
inline ::google::protobuf::uint32 FilenameEntry::entry_id() const {
  return entry_id_;
}
inline void FilenameEntry::set_entry_id(::google::protobuf::uint32 value) {
  set_has_entry_id();
  entry_id_ = value;
}

// required bytes encrypted_name = 2;
inline bool FilenameEntry::has_encrypted_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilenameEntry::set_has_encrypted_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilenameEntry::clear_has_encrypted_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilenameEntry::clear_encrypted_name() {
  if (encrypted_name_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_name_->clear();
  }
  clear_has_encrypted_name();
}
inline const ::std::string& FilenameEntry::encrypted_name() const {
  return *encrypted_name_;
}
inline void FilenameEntry::set_encrypted_name(const ::std::string& value) {
  set_has_encrypted_name();
  if (encrypted_name_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_name_ = new ::std::string;
  }
  encrypted_name_->assign(value);
}
inline void FilenameEntry::set_encrypted_name(const char* value) {
  set_has_encrypted_name();
  if (encrypted_name_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_name_ = new ::std::string;
  }
  encrypted_name_->assign(value);
}
inline void FilenameEntry::set_encrypted_name(const void* value, size_t size) {
  set_has_encrypted_name();
  if (encrypted_name_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_name_ = new ::std::string;
  }
  encrypted_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilenameEntry::mutable_encrypted_name() {
  set_has_encrypted_name();
  if (encrypted_name_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_name_ = new ::std::string;
  }
  return encrypted_name_;
}
inline ::std::string* FilenameEntry::release_encrypted_name() {
  clear_has_encrypted_name();
  if (encrypted_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_name_;
    encrypted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilenameEntry::set_allocated_encrypted_name(::std::string* encrypted_name) {
  if (encrypted_name_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_name_;
  }
  if (encrypted_name) {
    set_has_encrypted_name();
    encrypted_name_ = encrypted_name;
  } else {
    clear_has_encrypted_name();
    encrypted_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DirMapFile

// required string creator = 1;
inline bool DirMapFile::has_creator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirMapFile::set_has_creator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirMapFile::clear_has_creator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirMapFile::clear_creator() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    creator_->clear();
  }
  clear_has_creator();
}
inline const ::std::string& DirMapFile::creator() const {
  return *creator_;
}
inline void DirMapFile::set_creator(const ::std::string& value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void DirMapFile::set_creator(const char* value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void DirMapFile::set_creator(const char* value, size_t size) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirMapFile::mutable_creator() {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  return creator_;
}
inline ::std::string* DirMapFile::release_creator() {
  clear_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_;
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirMapFile::set_allocated_creator(::std::string* creator) {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (creator) {
    set_has_creator();
    creator_ = creator;
  } else {
    clear_has_creator();
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes iv = 2;
inline bool DirMapFile::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirMapFile::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirMapFile::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirMapFile::clear_iv() {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& DirMapFile::iv() const {
  return *iv_;
}
inline void DirMapFile::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void DirMapFile::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void DirMapFile::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirMapFile::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    iv_ = new ::std::string;
  }
  return iv_;
}
inline ::std::string* DirMapFile::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirMapFile::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::kEmptyString) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .secnfs.KeyBlock key_blocks = 3;
inline int DirMapFile::key_blocks_size() const {
  return key_blocks_.size();
}
inline void DirMapFile::clear_key_blocks() {
  key_blocks_.Clear();
}
inline const ::secnfs::KeyBlock& DirMapFile::key_blocks(int index) const {
  return key_blocks_.Get(index);
}
inline ::secnfs::KeyBlock* DirMapFile::mutable_key_blocks(int index) {
  return key_blocks_.Mutable(index);
}
inline ::secnfs::KeyBlock* DirMapFile::add_key_blocks() {
  return key_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >&
DirMapFile::key_blocks() const {
  return key_blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::secnfs::KeyBlock >*
DirMapFile::mutable_key_blocks() {
  return &key_blocks_;
}

// required .secnfs.FilenameEntry filenames = 4;
inline bool DirMapFile::has_filenames() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirMapFile::set_has_filenames() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirMapFile::clear_has_filenames() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirMapFile::clear_filenames() {
  if (filenames_ != NULL) filenames_->::secnfs::FilenameEntry::Clear();
  clear_has_filenames();
}
inline const ::secnfs::FilenameEntry& DirMapFile::filenames() const {
  return filenames_ != NULL ? *filenames_ : *default_instance_->filenames_;
}
inline ::secnfs::FilenameEntry* DirMapFile::mutable_filenames() {
  set_has_filenames();
  if (filenames_ == NULL) filenames_ = new ::secnfs::FilenameEntry;
  return filenames_;
}
inline ::secnfs::FilenameEntry* DirMapFile::release_filenames() {
  clear_has_filenames();
  ::secnfs::FilenameEntry* temp = filenames_;
  filenames_ = NULL;
  return temp;
}
inline void DirMapFile::set_allocated_filenames(::secnfs::FilenameEntry* filenames) {
  delete filenames_;
  filenames_ = filenames;
  if (filenames) {
    set_has_filenames();
  } else {
    clear_has_filenames();
  }
}

// optional bytes signature = 6;
inline bool DirMapFile::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirMapFile::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirMapFile::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirMapFile::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& DirMapFile::signature() const {
  return *signature_;
}
inline void DirMapFile::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DirMapFile::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DirMapFile::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirMapFile::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* DirMapFile::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirMapFile::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace secnfs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_secnfs_2eproto__INCLUDED
