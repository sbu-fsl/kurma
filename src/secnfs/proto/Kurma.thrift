include "Namespace.thrift"

namespace java edu.stonybrook.kurma.fs
namespace cpp secnfs.proto

// We could not use typedef because of problems in C_glib
// typedef Namespace.ObjectID OID;
// typedef Namespace.ObjectAttributes Attributes;
// typedef Namespace.DirEntry DEntry;

enum OpenFlags {
  CLOSED = 0
  READ = 1;
  WRITE = 2;
  SYNC = 4;
  RECLAIM = 8;
}

struct LockRange {
  1: i64 offset;
  2: i64 length;
  3: i32 type;
  4: i32 count;
}

// Data format for ephemeral znode that corresponds to a file open owner.
//
// Znode path: <file-znode>/OPENOWNER.xxx, where xxx is the openowner's name
struct OpenOwner {
  1: OpenFlags flags;          // bit field of OpenFlags
  2: list<LockRange> locks;
}

// File system dynamic info
struct DynamicInfo {
  1: i64 bytes;
  2: i64 files;
}

enum KurmaError {
  OKAY = 0;
  SESSION_NOT_EXIST = 10001;
  OBJECTID_INVALID = 10002;
  OBJECT_NOT_FOUND = 10003;
  ZOOKEEPER_ERROR = 10004;
  DIRECTORY_NOT_EMPTY = 10005;
  PERMISSION_DENIED = 10006;
  SERVER_ERROR = 10007;
  FILE_ALREADY_EXISTS = 10008;
  INVALID_OPERATION = 10009;
  NOT_DIRECTORY = 10010;
}

struct KurmaStatus {
  1: required i32 errcode = 0;
  2: optional string errmsg;
}

struct KurmaResult {
  1: KurmaStatus status;
  2: Namespace.ObjectAttributes new_attrs;
  // result of open(), create(), mkdir(), and create_volume()
  4: optional Namespace.ObjectID oid;

  // Compressed block versions, result of open().  Can be used for cache
  // invalidation at the granularity of blocks.
  5: optional binary block_versions;

  6: optional binary file_data;       // result of read()

  // result of listdir() and lookup()
  7: optional list<Namespace.DirEntry> dir_data;

  8: optional binary sessionid;       // result of create_session()
  9: optional i32 timeout_sec;        // result of create_session()

  // result of take_snapshot and lookup_snapshot
  10: optional i32 snapshot_id;
  11: optional i64 snapshot_time;
  
  12: optional DynamicInfo dynamic_info;
}

enum VolumeFormatFlags {
  CREATE = 1;
  RECREATE = 2;       // old data will be erased first
}

service KurmaService {
  KurmaResult format_volume(
      1: string volumeid,
      2: i32 flags,
  );
  
  // Return the bytes used by the volume in the ObjectAttributes.length.
  KurmaResult get_dynamic_info(
      1: binary sessionid,
  );

  // A sessionid is generated by server that uniquely identify an instance of
  // client (lifetime of a client) and the volume it is accessing.
  //
  // A session is closed by timeout; the client need to renew it periodically.
  KurmaResult create_session(
      1: binary clientid,
      2: string volumeid,
  );

  KurmaResult renew_session(
      1: binary sessionid,
  );

  // Open a file:
  // - Register current host as opener (ephemeral znode) of the file under ZK
  // - Decrypt file key,
  // - Load first block map,
  // - Register as observer of the file's REMOTECHANGES Znode
  KurmaResult open(
      1: binary sessionid,
      2: Namespace.ObjectID file_oid,
      3: OpenFlags flags,
  );

  KurmaResult close(
      1: binary sessionid,
      2: Namespace.ObjectID file_oid,
  );

  // If dir_oid.id is zero, i.e., id1 == id2 == 0, then the root dir will be
  // used as parent directory.
  KurmaResult create(
      1: binary sessionid,
      2: Namespace.ObjectID dir_oid,
      3: string name,
      4: Namespace.ObjectAttributes attrs,
  );

  // If dir_oid.id is zero, i.e., id1 == id2 == 0, then the root dir will be
  // used as parent directory.
  KurmaResult mkdir(
      1: binary sessionid,
      2: Namespace.ObjectID dir_oid,
      3: string name,
      4: Namespace.ObjectAttributes attrs,
  );

  // If dir_oid is unset, i.e., id1 == id2 == 0, then the root dir will be
  // used as parent directory.
  KurmaResult lookup(
      1: binary sessionid,
      2: Namespace.ObjectID dir_oid,
      3: string path,
  );

  KurmaResult read(
      1: binary sessionid,
      2: Namespace.ObjectID file_oid,
      3: i64 offset,            // has to be block-aligned
      4: i32 length,
  );

  KurmaResult write(
      1: binary sessionid,
      2: Namespace.ObjectID file_oid,
      3: i64 offset,            // has to be block-aligned
      4: binary data,
  );

  // If dir_oid is not set, i.e., id1 == id2 == 0, then the root dir will be
  // used as parent directory.
  KurmaResult listdir(
      1: binary sessionid,
      2: Namespace.ObjectID dir_oid,
  );

  KurmaResult getattrs(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
  );

  KurmaResult setattrs(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: Namespace.ObjectAttributes attrs,
  );

  KurmaResult rename(
      1: binary sessionid,
      2: Namespace.ObjectID src_dir_oid,
      3: string src_name,
      4: Namespace.ObjectID dst_dir_oid,
      5: string dst_name,
  );

  // If dir_oid is not set, i.e., id1 == id2 == 0, then the root dir will be
  // used as parent directory.
  // The oid of the removed directory entry will be set to KurmaResult::oid.
  KurmaResult unlink(
      1: binary sessionid,
      2: Namespace.ObjectID dir_oid,
      3: string name,
  );

  KurmaResult lock(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: LockRange locks,
  );

  KurmaResult unlock(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: LockRange locks,
  );

  // A snapshot can be identified by a 32-bit ID or a name.
  KurmaResult take_snapshot(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: string snapshot_name,   // need to be unique among snapshots of a file
      4: string description,
  );

  KurmaResult restore_snapshot(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: string snapshot_name,
      4: i32 id,
  );

  KurmaResult list_snapshots(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
  );

  KurmaResult delete_snapshot(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: string snapshot_name,
      4: i32 id,
  );

  KurmaResult lookup_snapshot(
      1: binary sessionid,
      2: Namespace.ObjectID oid,
      3: string snapshot_name,
      4: i32 id,
  );

  // TODO: commit()?
}
